package export

import (
	"bytes"
	"text/template"
)

type CsharpLanguageTemplateParam struct {
	ClassName  string
	DataDefine string
}

const csharpTemplateLanguage = `// Generated by code
// DO NOT EDIT!!
using System.Collections.Generic;

namespace Schema
{
	public partial class {{.ClassName}}:ISchemaLanguage, ISchema
	{
		private {{.ClassName}}Define _data;

		public {{.ClassName}}Define Data { get { return _data; } }

		public override string Get(string key)
        {
			if(!Data.language.TryGetValue(key, out var value))
            {
				LOG.DEBUG_WARN("没有找到语言：" + key);
				return string.Empty;
            }
            else
            {
				return value;
            }
		}

		public override  Dictionary<string, string>.KeyCollection GetKes()
        {
			return Data.language.Keys;
		}

		#region Deserialize code
		public void Deserialize(Config.DataReader reader )
		{
 			int tag = -1;
            while ( -1 != (tag = reader.ReadTag()))
            {
				var bound = reader._reader.ReadInt32();
				{{.ClassName}}Define element = new {{.ClassName}}Define(new Config.DataReader(reader, reader._reader.BaseStream.Position + bound));
				_data = element;
				break;
            } 
		}

		#endregion
		#region Clear Code
		public void Clear( )
		{			
			_data = null;
		}
		#endregion
		public void Release()
		{
			
		}
	} 

	[System.Serializable]
	public partial class {{.ClassName}}Define
	{
		{{.DataDefine}}
		public {{.ClassName}}Define(Config.DataReader reader)
		{
            int count = reader.ReadInt32();
			for(int i=0;i<count;i++)
			{
                language.Add(reader.ReadString(), reader.ReadString());
            }
    	}
	} 
}
`

func (c *CsharpLanguageTemplateParam) GenerateCsharpTemplate() string {
	var buf bytes.Buffer
	t := template.Must(template.New("deserialize").Parse(csharpTemplateLanguage))
	if err := t.Execute(&buf, c); err != nil {
		panic("template execution failed: " + err.Error())
	}
	return buf.String()
}
